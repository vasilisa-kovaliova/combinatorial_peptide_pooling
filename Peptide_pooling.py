#!/usr/bin/env python
# coding: utf-8

# In[1]:


import pandas as pd
import numpy as np
from itertools import combinations
import argparse
import random

parser = argparse.ArgumentParser(description='This script generates peptide pools, with parameters for the number of pools, the number of pools each peptide goes into, the ordered list of peptides, the number of undistinguished peptides allowed, and the file paths for the output of the pools and simulation results.')

parser.add_argument('-n_pools', type=int, help='number of peptide pools that will be generated by the script')
parser.add_argument('-iters', type=int, help='number of peptide pools to which a single peptide will be added')
parser.add_argument('-peptides', type=str, help='file path of the input file that contains the ordered list of peptides. The peptides must be separated by tabs and listed in the "SequenceAsEntered" column')
parser.add_argument('-unresolved', type=int, help='the maximum number of peptides that can be undistinguished in the simulation. Ideally, this value should be set to 0, but in cases where peptides overlap significantly, it may not be possible')
parser.add_argument('-pools', type=str, help='file path for the output file where the generated peptide pools will be written')
parser.add_argument('-simulation', type=str, help='file path for the output file where the simulation results will be written, with each possible epitope activated')

args = parser.parse_args()

if args.n_pools is None or args.iters is None or args.peptides is None or args.unresolved is None or args.pools is None or args.simulation is None:
    print('Missing one or more required arguments.')
elif args.iters >= args.n_pools:
    print('iters must be less than n_pools.')
else:
    print('n_pools:', args.n_pools)
    print('iters:', args.iters)
    print('peptides:', args.peptides)
    print('unresolved:', args.unresolved)
    print('pools:', args.pools)
    print('simulation:', args.simulation)

n_pools = int(args.n_pools)
iters = int(args.iters)
lst = list(pd.read_csv(args.peptides, sep = "\t")['SequenceAsEntered'])
unresolved = int(args.unresolved)
output_file = args.pools
simulation_file = args.simulation

def TCR_activation(pools, epitope):
    activated_pools = []
    for key in pools.keys():
        for item in pools[key]:
            if epitope in item:
                activated_pools.append(key)
                    
    activated_pools = list(set(activated_pools))              
    return activated_pools

def exp_simulation(activated_pools, pools, iters):

    ### Search for possible peptide for the combination of these pools
    pools_combinations = list(combinations(activated_pools, r = iters))
    chosen_peptides = []
    for pools4 in pools_combinations:
        peptides = []
        for item in pools4:
            if peptides == []:
                peptides = set(pools[item])
            else:
                peptides = set(peptides).intersection(set(pools[item]))
        for peptide in peptides:
            chosen_peptides.append(peptide)
            
    possible_peptides = {key: [] for key in activated_pools}
    for peptide in chosen_peptides:
        for item in activated_pools:
            if peptide in pools[item] and peptide not in possible_peptides[item]:
                possible_peptides[item].append(peptide)
    ### Search for possible epitopes for the combination of these pools          
    possible_epitopes = dict()
    for key in possible_peptides.keys():
        possible_epitopes[key] = []
        peptides = possible_peptides[key]
        ### Sliding window for obtaining epitopes from these peptides
        for i in range(len(peptides)):
            for x in range(len(peptides[i])):
                seq = peptides[i][x:x+8]
                if len(seq) == 8:
                    if seq not in possible_epitopes[key]:
                        possible_epitopes[key].append(seq)
    ### Intersection of epitopes                     
    resulting_epitopes = []
    for key in possible_epitopes.keys():
        if len(resulting_epitopes) == 0:
            resulting_epitopes = set(possible_epitopes[key])
        else:
            resulting_epitopes = resulting_epitopes.intersection(set(possible_epitopes[key]))
    
    resulting_peptides = []
    for peptide in chosen_peptides:
        decision = []
        for epitope in resulting_epitopes:
            if epitope in peptide:
                decision.append('Yes')
        if 'Yes' in decision:
            resulting_peptides.append(peptide)
    return resulting_epitopes, set(resulting_peptides)

def run_experiment(lst, peptide_address, pools, iters):
    check_results = pd.DataFrame(columns = ['Peptide', 'Address', 'Epitope', 'Act Pools',
                                        '# of pools', '# of ep', '# of peptides'])
    for x in range(len(lst)):
        p = lst[x]
        ad = peptide_address[p]
        for i in range(len(p)):
            ep = p[i:i+8]
            if len(ep)==8:
                act = TCR_activation(epitope = ep, pools=pools)
                r = exp_simulation(activated_pools = act, pools=pools, iters=iters)
                row = {'Peptide':p, 'Address':ad, 'Epitope':ep, 'Act Pools':act,
                  '# of pools':len(act), '# of ep':len(r[0]), '# of peptides':len(r[1])}
                check_results = pd.concat([check_results, pd.DataFrame.from_dict(row, orient='index').T],
                                          ignore_index=True)
    return check_results

def close_address_search(address, limit, all_ns, remain):
    address_index = all_ns.index(tuple(address))
    close_address = {'close1':'', 'close2':''}
    ### Index limits
    lim1 = limit[0]
    lim2 = limit[1]
    while close_address['close1'] == '':
        for i in range(1, address_index):
            if address_index-i >= lim1:
                if close_address['close1'] == '':
                    close1 = all_ns[address_index-i]
                    if close1 in remain:
                        close_address['close1'] = list(close1)
            else:
                r_choice = 'r2'
                while r_choice != close_address['close2']:
                    r_choice = list(random.choice(remain))
                    close_address['close1'] = r_choice
                    
    while close_address['close2'] == '':
        for i in range(1, address_index):
            if address_index+i <= lim2:
                if close_address['close2'] == '':
                    close2 = all_ns[address_index+i]
                    if close2 in remain:
                        close_address['close2'] = list(close2)
            else:
                r_choice = 'r1'
                while r_choice != close_address['close1']:
                    r_choice = list(random.choice(remain))
                    close_address['close2'] = list(random.choice(remain))    
                
    return close_address

def bad_address_predictor(all_ns):
    for i in range(len(all_ns)-1, 1, -1):
        n1 = all_ns[i]
        n2 = all_ns[i-1]
        n3 = all_ns[i-2]
        if set(n1 + n2) == set(n2 + n3) or set(n1 + n2) == set(n1 + n3):
            all_ns.remove(n1)
    return all_ns

def reassign_addresses(conf_acts, pools, remain, peptide_address, check_results, all_ns):
    
    conf_acts = set(tuple(l) for l in conf_acts)
    conf_acts = [list(t) for t in conf_acts]
    conf_acts = sorted(conf_acts)

    for conf_act in conf_acts:
        conf_peptides = list(check_results['Peptide'][check_results['Act Pools'].apply(set) == set(conf_act)].drop_duplicates())
    
        while len(conf_peptides) > 2:
            conf_peptide = conf_peptides[-1]
            bad_address = peptide_address[conf_peptide]
            
            ## Selection of new address for it to be closest to previous one,
            ## And also creating the least number of activated pools with previous peptide
            next_peptide = conf_peptides[-2]
            next_address = peptide_address[next_peptide]
            close_addresses = close_address_search(address = bad_address, limit = [0, len(all_ns)-1],
                                                   all_ns = all_ns, remain = remain)
            lengths = {k: len(set(v + next_address)) for k, v in close_addresses.items()}
            close_address = close_addresses[min(lengths, key=lengths.get)]
    
            ### Removal of peptide's previous address
            for key in bad_address:
                pools[key].remove(conf_peptide)
            peptide_address[conf_peptide] = close_address
            
            ### Addition of peptide to new address
            for key in close_address:
                pools[key].append(conf_peptide)
    
            ### Removal of selected address from remain
            remain.remove(tuple(close_address))
    
            ### Removal of peptide from unresolved peptides:
            conf_peptides.remove(conf_peptide)
            
    return pools, remain, peptide_address

def balanced_pooling(iters, n_pools, lst, unresolved_max):
    bads = [1]
    another_count = 1
    while another_count != 4 and len(set(bads)) != unresolved_max:
        all_ns = list(combinations(list(range(n_pools)), r = iters))
        all_ns = bad_address_predictor(all_ns)
        ns = random.sample(all_ns, len(lst))
        ns = sorted(ns)
        remain = f = [x for x in all_ns if x not in ns]

        result = []
        for n in ns:
            result.append(list(n))

        pools = {key: [] for key in range(n_pools)}
        peptide_address = dict()

        for i in range(len(lst)):
            peptide = lst[i]
            peptide_pools = result[i]
            peptide_address[peptide] = peptide_pools
            for item in peptide_pools:
                pools[item].append(peptide)
        
        ### Collision check
        check_results = run_experiment(lst=lst, peptide_address=peptide_address, pools=pools, iters=iters)  
        bads = check_results['Peptide'][check_results['# of peptides'] > 2]
        print('Unresolved peptides', len(set(bads)), 'out of', len(lst))
        
        len_bads = []
        count = 0
        while len(set(bads)) != unresolved_max:
            conf_acts = check_results['Act Pools'][check_results['# of peptides'] > 2]
            pools, remain, peptide_address = reassign_addresses(conf_acts = conf_acts, pools = pools,
                                                        remain = remain, peptide_address = peptide_address,
                                                                check_results = check_results, all_ns = all_ns)
        
            ### Collision check
            check_results = run_experiment(lst=lst, peptide_address=peptide_address, pools=pools, iters=iters)
            bads = check_results['Peptide'][check_results['# of peptides'] > 2]
            print('Unresolved peptides', len(set(bads)), 'out of', len(lst))
        
            len_bads.append(len(set(bads)))
            if len(len_bads) >= 3:
                if len_bads[-1] >= len_bads[-2]:
                    if count == 4:
                        print('Oh-ho, probably you should choose another parameters, but we need to check it again')
                        break
                    else:
                        count += 1
                
        another_count += 1
    return pools, peptide_address

 
try:
    pools, peptide_address = balanced_pooling(iters=iters, n_pools=n_pools, lst=lst, unresolved_max=unresolved)
except ValueError or IndexError:
    print('There are not enough addresses for your number of peptides.')
    print('Try another set of parameters.')
check = run_experiment(lst=lst, peptide_address=peptide_address, pools=pools, iters=iters)
if len(set(check['Peptide'][check['# of peptides'] > 2])) > unresolved:
    print('Try another set of parameters.')
    print('Or maybe you should check whether your peptides are ordered and/or overlap by more than 12 amino acids')
    print('Unresolved peptides; ', len(set(check['Peptide'][check['# of peptides'] > 2])) )
    for key in pools.keys():
        print('pool_'+str(key), len(pools[key]))
    with open(output_file, 'w') as f:
        for key in pools.keys():
            f.write(str(key) + '\n')
            for item in pools[key]:
                f.write(item + '\n')
    check.to_csv(simulation_file, index = None, sep = '\t')

elif len(set(check['Peptide'][check['# of peptides'] > 2])) <= unresolved:
    for key in pools.keys():
        print('pool_'+str(key), len(pools[key]))
    with open(output_file, 'w') as f:
        for key in pools.keys():
            f.write(str(key) + '\n')
            for item in pools[key]:
                f.write(item + '\n')
    check.to_csv(simulation_file, index = None, sep = '\t')

